cmap - 字符到字形索引映射表
===========================


本表定义字符编码到字体中字形索引值的映射。为了支持多种字符编码方案，它可能包含多个子表。

概述
----------------------

此表定义了字符编码到默认字形索引的映射。可以定义不同的子表，每个子表都包含不同字符编码方案的映射。表头指示存在子表的字符编码。

无论采用何种编码方案，与字体中任何字形都不对应的字符编码都应映射到字形索引
0。此位置的字形必须是表示缺失字符的特殊字形，通常称为 .notdef。

每个子表采用七种可能的格式之一，并以指示所用格式的格式字段开头。前四种格式——格式
0、2、4 和 6——最初是在 Unicode 2.0 之前定义的。这些格式允许 8
位单字节、8 位多字节和 16 位编码。随着 Unicode 2.0
中补充平面的引入，Unicode 可寻址代码空间扩展到超过 16
位。为了适应这一点，添加了三种额外的格式——格式 8、10 和 12——允许 32
位编码方案。

Unicode 中的其他增强功能导致添加了其他子表格式。子表格式 13
允许将许多字符有效地映射到单个字形；这对于为所有可能的 Unicode
字符提供后备渲染的“最后手段”字体非常有用，并为不同的 Unicode
范围提供了不同的后备字形。子表格式 14 为支持 Unicode
变体序列提供了统一的机制。

在七种可用格式中，并非所有格式都是当今常用的。格式 4 或 12
适用于大多数新字体，具体取决于支持的 Unicode 字符库。格式 14
在许多应用程序中用于支持 Unicode 变体序列。一些平台还使用格式 13
作为最后的后备字体。不建议在新字体中使用其他子表格式。然而，应用程序开发人员应该预料到任何格式都可以在字体中使用。

   *注意：*\ 对于使用较新的子表格式的字体，“cmap”表版本号保持为 0x0000。

标题
------------------------------

字符到字形索引映射表组织如下：


======== ========================== ================
类型     姓名                       描述
======== ========================== ================
uint16   版本                       表版本号 (0)。
uint16   numTables                  后面的编码表数。
编码记录 encodingRecords[numTables] 
======== ========================== ================

编码记录和编码
------------------------------------------------------

编码记录数组为每​​个编码指定特定的编码和子表的偏移量。

*编码记录：*

======== ======== ====================================
类型     姓名     描述
======== ======== ====================================
uint16   平台ID   平台标识。
uint16   编码ID   特定于平台的编码 ID。
偏移量32 子表偏移 从表开始到此编码的子表的字节偏移量。
======== ======== ====================================

编码记录中的平台 ID 和平台特定编码 ID 用于指定特定的字符编码。在
Macintosh 平台的情况下，映射子表中的语言字段也用于此目的。

'cmap' 标头中的编码记录条目必须首先按平台 ID 排序，然后按平台特定的编码
ID，然后按相应子表中的语言字段。每个平台 ID、平台特定编码 ID
和子表语言组合在“cmap”表中只能出现一次。

除了格式为 14
的子表之外，所有其他子表都是排他的：应用程序应该选择并使用其中的一个，而忽略其他的。如果使用
Unicode 子表（平台 0，或平台 3/编码 1 或 10），则也可以补充使用平台
0/编码 5 的格式 14 子表来映射 Unicode 变化序列。

如果字体包含 16 位编码（通常是格式 4）和 32 位编码（格式 10 或 12）的
Unicode 子表，则 32 位编码的子表支持的字符应该是字符的超集子表支持 16
位编码，应用程序应使用 32 位编码。

字体不应包含同时使用格式 4 和格式 6 的 16 位 Unicode 子表；应使用格式
4。同样，字体不应包含同时使用格式 10 和格式 12 的 32 位 Unicode
子表；应使用格式 12。

如果字体包含相同格式但具有不同平台 ID 的 Unicode
子表的编码记录，则应用程序可以选择选择哪个，但每次使用该字体时都应始终进行此选择。

平台 ID
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

定义了以下平台 ID：

+----------+----------------+----------------------------------------+
| 平台编号 | 平台名称       | 特定于平台的编码 ID                    |
+==========+================+========================================+
| 0        | 统一码         | `各种各样的                            |
|          |                |  <#unicode-platform-platform-id--0>`__ |
+----------+----------------+----------------------------------------+
| 1        | 麦金塔         | `脚本管理器代码 <                      |
|          |                | #macintosh-platform-platform-id--1>`__ |
+----------+----------------+----------------------------------------+
| *2*      | *ISO [已弃用]* | `ISO                                   |
|          |                | 编码 <#iso-pla                         |
|          |                | tform-platform-id--2>`__\ *\ [已弃用]* |
+----------+----------------+----------------------------------------+
| 3        | 视窗           | `Windows                               |
|          |                | 编码                                   |
|          |                |  <#windows-platform-platform-id--3>`__ |
+----------+----------------+----------------------------------------+
| 4        | 风俗           | `风俗 <                                |
|          |                | #custom-platform-platform-id--4-and-ot |
|          |                | f-windows-nt-compatibility-mapping>`__ |
+----------+----------------+----------------------------------------+

自 OpenType 版本 v1.3 起，平台 ID 2 (ISO) 已被弃用。

平台 ID 值 240 到 255
是为用户定义的平台保留的。本规范永远不会将这些值分配给已注册的平台。

Unicode 平台（平台 ID = 0）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

定义了以下编码 ID 以用于 Unicode 平台：

======= ==============================================
编码 ID 描述
0       Unicode 1.0 语义\ *——已弃用*
1       Unicode 1.1 语义\ *——已弃用*
2       ISO/IEC 10646 语义——*已弃用*
3       Unicode 2.0 及更高版本的语义，仅限 Unicode BMP
4       Unicode 2.0 及更高版本的语义，Unicode 完整曲目
5       Unicode 变体序列——用于子表格式 14
6       Unicode 完整曲目——用于子表格式 13
======= ==============================================

不推荐使用编码 ID 0、1 或 2。

编码 ID 3 应与“cmap”子表格式 4 或 6 一起使用。编码 ID 4 应与子表格式 10
或 12 一起使用。

字体支持的 Unicode 变化序列应在“cmap”表中使用格式 14 子表指定。格式 14
的子表只能在平台 ID 0 和编码 ID 5 下使用；并且编码 ID 5 只能与格式 14
的子表一起使用。

编码 ID 6 只能与 'cmap' 子表格式 13 结合使用；和子表格式 13 只能在平台
ID 0 和编码 ID 6 下使用。

Macintosh 平台（平台 ID = 1）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

较旧的 Macintosh 版本要求字体具有平台 ID 1 的“cmap”子表。对于当前的
Apple 平台，不鼓励使用平台 ID 1。有关为 Macintosh 平台定义的编码 ID
的详细信息，请参阅\ `“名称” <name#macintosh-encoding-ids-script-manager-codes>`__\ 表章节。

ISO 平台（平台 ID = 2）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*注意：*\ 不推荐使用此平台 ID。

定义了以下编码 ID 用于 ISO 平台：

==== ==========
代码 ISO 编码
0    7 位 ASCII
1    ISO 10646
2    ISO 8859-1
==== ==========

Windows 平台（平台 ID = 3）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Windows 平台支持多种编码。在为 Windows 创建字体时，应始终使用 Unicode
'cmap' 子表 — 平台 ID 3 和编码 ID 1 或编码 ID
10。有关更多详细信息，请参见下文。

Windows 平台支持以下编码 ID：

Windows 编码

======== ======= ================
平台编号 编码 ID 描述
======== ======= ================
3        0       象征
3        1       Unicode BMP
3        2       ShiftJIS
3        3       中华人民共和国
3        4       大五
3        5       万松
3        6       约哈布
3        7       预订的
3        8       预订的
3        9       预订的
3        10      Unicode 完整曲目
======== ======= ================

Windows 平台上仅支持 Unicode BMP 字符（U+0000 到
U+FFFF）的字体必须使用编码 1 和格式 4 子表。此编码不得用于支持 Unicode
补充平面字符。

Windows 平台上支持 Unicode 补充平面字符（U+10000 到
U+10FFFF）的字体必须使用编码 10 和格式 12 的子表。

创建符号编码是为了支持带有 Unicode
或其他标准编码不支持的任意装饰或符号的字体。将使用格式 4 子表，通常在以
0xF020 开头的代码位置分配多达 224 个图形字符。这对应于 Unicode 专用区
(PUA) 中的一个子范围，尽管这不是 Unicode
编码。在传统用法中，一些应用程序会使用单字节编码来表示文本中的符号字符，然后将
0x20 映射到字体中的 OS/2.usFirstCharIndex 值。在新字体中，非 Unicode
符号或字符应使用 Unicode 'cmap' 子表中的 PUA 代码点进行编码。

有关更多信息，请参阅“\ `建议 <recom#cmap-table>`__\ ”一章。

自定义平台（平台 ID = 4）和 OTF Windows NT 兼容性映射
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Platform ID 4 是一个遗留平台，它的创建是为了提供旧应用程序与从旧 Type 1
字体改编而来的 OpenType
字体的兼容性。这个平台今天不常用，不应该在新字体中使用。

===== =========================
ID    自定义编码
0-255 OTF Windows NT 兼容性映射
===== =========================

这个“cmap”平台为使用字体的非 Unicode
应用程序提供了一种兼容性机制，就好像它是 Windows ANSI 编码的一样。Adobe
过去发布的非 Windows ANSI Type 1 字体，例如 Cyrillic 和 Central European
字体，在 .PFM 文件的 CharSet 字段中记录了“0”（Windows ANSI）；ATM for
Windows 9x 完全忽略了 CharSet。Adobe 在每个从 Type1 字体转换而来的
OpenType 字体中都提供了这种兼容性“cmap”编码，其中 Encoding 不是
StandardEncoding。

使用平台 ID 4 时，编码 ID 必须设置为原始 Type 1 字体的 .PFM 文件中存在的
Windows 字符集值（范围为 0 到 255，包括 0 到 255）。

如果平台 ID 4（自定义）、编码 ID 0-255（OTF Windows NT
兼容性映射）“cmap”编码存在于带有 CFF 轮廓的 OpenType 字体中，则 Windows
NT 中的 OTF 字体驱动程序将：(a) 叠加在相应的 Windows ANSI（代码页
1252）上的编码中以字符编码 0-255 编码的字形 它报告给系统的 Unicode
编码中的 Unicode 值；(b) 将 Windows ANSI (CharSet 0)
添加到字体支持的字符集列表中；(c) 将编码 ID 的值视为 Windows CharSet
值，并将其添加到字体支持的 CharSet
列表中。注意：“cmap”子表的子表必须使用格式 0 或 6，并且编码必须与 CFF
的编码相同。

在“cmap”子表中使用语言字段
-------------------------------------------------------------------------------

对于平台 ID 不是 Macintosh（平台 ID
1）的所有“cmap”子表，语言字段必须设置为零。对于平台 ID 为 Macintosh
的“cmap”子表，将此字段设置为“cmap”子表的 Macintosh 语言 ID
加一，如果“cmap”子表不是特定于语言的，则设置为零。例如，Mac OS
土耳其语“cmap”子表必须将此字段设置为 18，因为土耳其语的 Macintosh 语言
ID 是 17。Mac OS 罗马语“cmap”子表必须将此字段设置为 0，因为 Mac OS Roman
不是特定于语言的编码。

格式0：字节编码表
-------------------------------------------------------

格式 0 是旧 Macintosh 平台上使用的标准映射子表，但在较新的 Apple
平台上不需要。

*'cmap' 子表格式 0：*

+--------+-------------------+---------------------------------------+
| 类型   | 姓名              | 描述                                  |
+========+===================+=======================================+
| uint16 | 格式              | 格式编号设置为 0。                    |
+--------+-------------------+---------------------------------------+
| uint16 | 长度              | 这是子表的字节长度。                  |
+--------+-------------------+---------------------------------------+
| uint16 | 语                | 语言字段的使用要求请参见本文档“       |
|        |                   | `'cmap'子                             |
|        |                   | 表中语言字段的使用”。 <#language>`__  |
+--------+-------------------+---------------------------------------+
| uint8  | glyphIdArray[256] | 将字符编码映射到字形索引值的数组。    |
+--------+-------------------+---------------------------------------+

这是字符编码到字形索引的简单 1 对 1 映射。字形集限制为 256
个。请注意，如果使用此格式来索引更大的字形集，则只能访问前 256 个字形。

格式2：通过表的高字节映射
---------------------------------------------------------------------------

此子表格式是为遵循用于日文、中文和韩文字符的国家字符编码标准的“双字节”编码创建的。这些代码标准使用混合的
8 位/16 位编码。这种格式今天不常用。

在这些混合的 8 位/16 位编码中，某些字节值表示 2
字节字符的第一个字节。（这些字节值作为 2
字节字符的第二个字节也是有效的。）此外，即使对于 2
字节字符，字符编码到字形索引值的映射也很大程度上取决于第一个字节。因此，该表以将第一个字节映射到
SubHeader 记录的数组开始。对于 2 字节字符编码，SubHeader 用于通过
subArray 映射第二个字节的值，如下所述。在处理 8 位/16
位混合文本时，SubHeader 0 是特殊的：它用于单字节字符编码。当使用
SubHeader 0 时，不需要第二个字节；单字节值通过 subArray 映射。

*'cmap' 子表格式 2：*

+--------+-----------------+-----------------------------------------+
| 类型   | 姓名            | 描述                                    |
+========+=================+=========================================+
| uint16 | 格式            | 格式编号设置为 2。                      |
+--------+-----------------+-----------------------------------------+
| uint16 | 长度            | 这是子表的字节长度。                    |
+--------+-----------------+-----------------------------------------+
| uint16 | 语              | 语言字段的使用要求请参见本文档“         |
|        |                 | `'cmap                                  |
|        |                 | '子表中语言字段的使用”。 <#language>`__ |
+--------+-----------------+-----------------------------------------+
| uint16 | 子标题键[256]   | 将高字节映射到 subHeaders 的数组：值为  |
|        |                 | subHeader index × 8。                   |
+--------+-----------------+-----------------------------------------+
| 子标题 | 子标题[]        | SubHeader 记录的可变长度数组。          |
+--------+-----------------+-----------------------------------------+
| uint16 | glyphIdArray[ ] | 可变长度数组，包含用于映射 2            |
|        |                 | 字节字符的低字节的子数组。              |
+--------+-----------------+-----------------------------------------+

SubHeader 的结构如下：

*子标题记录：*

====== ============= =================================
类型   姓名          描述
====== ============= =================================
uint16 第一码        此 SubHeader 的第一个有效低字节。
uint16 条目计数      此 SubHeader 的有效低字节数。
整数16 idDelta       见下文。
uint16 idRangeOffset 见下文。
====== ============= =================================

firstCode 和 entryCount 值指定从 firstCode 开始且长度等于 entryCount
值的子范围。该子范围保持在被映射字节的 0-255
范围内。此子范围之外的字节被映射到字形索引
0（缺少字形）。此子范围内字节的偏移量随后用作 glyphIdArray
的相应子数组的索引。这个子数组的长度也是 entryCount。idRangeOffset
的值是超过 idRangeOffset 字的实际位置的字节数，其中出现对应于 firstCode
的 glyphIdArray 元素。

最后，如果从子数组中获取的值不为 0（表示缺少 glyph），则应为其添加
idDelta 以获取 glyphIndex。值 idDelta
允许将相同的子数组用于多个不同的子标题。idDelta 算术是模 65536。

格式 4：段映射到增量值
------------------------------------------------------------------------

这是仅支持 Unicode 基本多语言平面字符（U+0000 到
U+FFFF）的字体的标准字符到字形索引映射子表。

   *注意：*\ 要支持 Unicode 补充平面字符，应使用\ `格式 12
   。 <#format-12-segmented-coverage>`__

当字体所代表的字符的字符编码落入几个连续范围内时使用此格式，可能在部分或全部范围内有孔（即，一个范围内的某些代码可能在字体中没有表示形式）
）。与格式相关的数据分为三个部分，它们必须按以下顺序出现：

#. 一个四字标题为优化搜索段列表提供了参数；
#. 四个平行数组描述这些段（每个连续的代码范围一个段）；
#. 字形 ID（无符号字）的可变长度数组。

*'cmap' 子表格式 4：*

+--------+--------------------------+-----------------------------+
| 类型   | 姓名                     | 描述                        |
+========+==========================+=============================+
| uint16 | 格式                     | 格式编号设置为 4。          |
+--------+--------------------------+-----------------------------+
| uint16 | 长度                     | 这是子表的字节长度。        |
+--------+--------------------------+-----------------------------+
| uint16 | 语                       | 语言                        |
|        |                          | 字段的使用要求请参见本文档“ |
|        |                          | `'cmap'子表中语言字         |
|        |                          | 段的使用”。 <#language>`__  |
+--------+--------------------------+-----------------------------+
| uint16 | segCountX2               | 2 × 段数。                  |
+--------+--------------------------+-----------------------------+
| uint16 | 搜索范围                 | 2 的最大幂小于或等于        |
|        |                          | segCount，乘以 2            |
|        |                          | ((2**floor(log :sub:`2`     |
|        |                          | (segCount))) \*             |
|        |                          | 2，其中“**”是幂运算符）     |
+--------+--------------------------+-----------------------------+
| uint16 | 入口选择器               | :sub:`2`\ 的最大幂的log     |
|        |                          | 2小于等于 numTables (log    |
|        |                          | :sub:`2` (searchRange/2),   |
|        |                          | 等于 floor(log :sub:`2`     |
|        |                          | (segCount)))                |
+--------+--------------------------+-----------------------------+
| uint16 | 范围移位                 | segCount 乘以 2，减去       |
|        |                          | searchRange ((segCount \*   |
|        |                          | 2) - searchRange)           |
+--------+--------------------------+-----------------------------+
| uint16 | endCode[segCount]        | 每个段的                    |
|        |                          | 结束字符编码，last=0xFFFF。 |
+--------+--------------------------+-----------------------------+
| uint16 | 保留垫                   | 设置为 0。                  |
+--------+--------------------------+-----------------------------+
| uint16 | 起始码[segCount]         | 每个段的起始字符编码。      |
+--------+--------------------------+-----------------------------+
| 整数16 | idDelta[segCount]        | 段中所有字符编码的增量。    |
+--------+--------------------------+-----------------------------+
| uint16 | idRangeOffsets[segCount] | 偏移到 glyphIdArray 或 0    |
+--------+--------------------------+-----------------------------+
| uint16 | glyphIdArray[ ]          | 字形索引数组（任意长度）    |
+--------+--------------------------+-----------------------------+

段数由 segCount 指定，它没有直接在标题中给出，但很容易从 segCountX2
派生。所有其他标头参数都是从它派生的。searchRange 值是小于或等于
segCount 的 2 的最大幂的两倍。例如，如果 segCount=39，我们有以下内容：

========== ==========================
segCountX2 78                             
搜索范围   64 (= 2 × 2 的最大幂 <=39)     
入口选择器 5 (= 日志\ :sub:`2` 32)        
范围移位   14 (= 2 × 39 - 64)             
========== ==========================

为了帮助进行快速二分搜索，包含 searchRange、entrySelector 和 rangeShift
字段作为可用于配置搜索算法的参数。特别是，当条目数是 2
的幂时，二分搜索是最佳的。searchRange
字段提供了可以使用该约束搜索的最大项目数（2 的最大幂）。rangeShift
字段提供了还需要搜索的剩余项目数。entrySelector
字段表示需要输入二叉树的最大级别数。

在硬件功能有限的设备上的早期实现中，searchRange、entrySelector 和
rangeShift
字段提供的优化非常重要。它们在现代设备上的重要性较低，但仍可能在某些实现中使用。但是，不正确的值可能会被用作针对某些实现的攻击向量。由于这些值可以在解析文件时从
numTables 字段导出，因此强烈建议解析实现不要依赖字体中的
searchRange、entrySelector 和 rangeShift 字段，而是独立于 numTables
导出它们。但是，字体文件应继续为这些字段提供有效值，以保持与所有现有实现的兼容性。

每个段由 startCode 和 endCode 以及 idDelta 和 idRangeOffset
描述，用于映射段中的字符编码。段按 endCode
值递增的顺序排序，段值在四个并行数组中指定。您搜索大于或等于要映射的字符编码的第一个
endCode。如果对应的 startCode 小于或等于字符编码，则使用对应的 idDelta
和 idRangeOffset 将字符编码映射到字形索引（否则返回
missingGlyph）。要终止搜索，最终的起始码和结束码值必须为
0xFFFF。该段不需要包含任何有效的映射。（它可以只将单个字符编码 0xFFFF
映射到 missingGlyph）。但是，该段必须存在。

如果段的 idRangeOffset 值不为 0，则字符编码的映射依赖于
glyphIdArray。startCode 的字符编码偏移量被添加到 idRangeOffset
值。此总和用作与 idRangeOffset 本身内的当前位置的偏移量，以索引出正确的
glyphIdArray 值。这种晦涩的索引技巧很有效，因为 glyphIdArray
紧跟在字体文件中的 idRangeOffset 之后。产生字形索引的 C 表达式是：



.. code:: 

   glyphId = *(idRangeOffset[i]/2
               + (c - startCode[i])
               + &idRangeOffset[i])

值\ *c*\ 是所讨论的字符编码，而\ *i*\ 是出现\ *c*\ 的段索引。如果索引操作得到的值不为0（表示缺少Glyph），则将idDelta[i]加到其中得到字形索引。idDelta
算术是模 65536。

如果 idRangeOffset 为 0，则将 idDelta
值直接添加到字符编码偏移量（即\ ``idDelta[i] + c``\ ）以获得相应的字形索引。同样，idDelta
算术是模 65536。

例如，将字符 10-20、30-90 和 153-480
映射到连续范围的字形索引的表的变体部分可能如下所示：

=============== ================
segCountX2：    8                    
搜索范围：      8                    
入口选择器：    4                    
范围转移：      0                    
结束代码：      20 90 480 0xffff     
保留垫：        0                    
起始码：        10 30 153 0xffff     
idDelta：       -9 -18 -80 1         
idRangeOffset： 0 0 0 0              
=============== ================

此表执行以下映射：

   | 10 ⇒ 10 - 9 = 1
   | 20 ⇒ 20 - 9 = 11
   | 30 ⇒ 30 - 18 = 12
   | 90 ⇒ 90 - 18 = 72
   | 153 ⇒ 153 - 80 = 73
   | 480 ⇒ 480 - 80 = 400
   | 0xffff ⇒ 0

请注意，增量值可能会被重新处理，以便对段重新排序。

格式 6：修剪表映射
----------------------------------------------------------

格式 6 旨在当字体的字符编码落入单个连续范围时将 16
位字符映射到字形索引。

*'cmap' 子表格式 6：*

+--------+--------------------------+-----------------------------+
| 类型   | 姓名                     | 描述                        |
+========+==========================+=============================+
| uint16 | 格式                     | 格式编号设置为 6。          |
+--------+--------------------------+-----------------------------+
| uint16 | 长度                     | 这是子表的字节长度。        |
+--------+--------------------------+-----------------------------+
| uint16 | 语                       | 语言                        |
|        |                          | 字段的使用要求请参见本文档“ |
|        |                          | `'cmap'子表中语言字         |
|        |                          | 段的使用”。 <#language>`__  |
+--------+--------------------------+-----------------------------+
| uint16 | 第一码                   | 子范围的第一个字符编码。    |
+--------+--------------------------+-----------------------------+
| uint16 | 条目计数                 | 子范围内的字符编码数。      |
+--------+--------------------------+-----------------------------+
| uint16 | glyphIdArray[entryCount] | 范围内                      |
|        |                          | 字符编码的字形索引值数组。  |
+--------+--------------------------+-----------------------------+

firstCode 和 entryCount 值指定可能的字符编码范围内的子范围（从 firstCode
开始，长度 = entryCount）。此子范围之外的代码映射到字形索引
0。此子范围内的代码（从第一个代码）的偏移量用作提供字形索引值的
glyphIdArray 的索引。

格式 8：混合 16 位和 32 位覆盖
---------------------------------------------------------------------------------

子表格式 8 旨在支持 UTF-16 编码中的 Unicode
补充平面字符，尽管它并不常用。格式 8 类似于格式
2，因为它提供混合长度的字符编码。但是，它不允许使用 8 位和 16
位字符编码，而是允许使用 16 位和 32 位字符编码。

如果字体包含 Unicode 补充平面字符（U+10000 到
U+10FFFF），那么它很可能也包含 Unicode BMP 字符（U+0000 到
U+FFFF）。因此，需要映射 16 位和 32
位字符编码的混合。做了一个简化的假设：即，没有 32 位字符编码与任何 16
位字符编码共享相同的前 16 位。（由于 Unicode 代码空间仅扩展到
U+10FFFF，因此仅对字符 U+0000 到 U+0010
存在潜在冲突，这些字符是非打印控制字符。）这意味着确定特定的 16
位是否value 是一个独立的字符编码，或者可以通过直接查看 16 位值来生成 32
位字符编码的开头，无需进一步的信息。

*'cmap' 子表格式 8：*

+------------+---------------+---------------------------------------+
| 类型       | 姓名          | 描述                                  |
+============+===============+=======================================+
| uint16     | 格式          | 子表格式；设置为 8。                  |
+------------+---------------+---------------------------------------+
| uint16     | 预订的        | 预订的; 设置为 0                      |
+------------+---------------+---------------------------------------+
| uint32     | 长度          | 此子表的字节长度（包括表头）          |
+------------+---------------+---------------------------------------+
| uint32     | 语            | 语言字段的使用要求请参见本文档“       |
|            |               | `'cmap'子                             |
|            |               | 表中语言字段的使用”。 <#language>`__  |
+------------+---------------+---------------------------------------+
| uint8      | is32[8192]    | 紧密打包的位数组（总共 8K             |
|            |               | 字节），指示特定的 16                 |
|            |               | 位（索引）值是否是 32                 |
|            |               | 位字符编码的开始                      |
+------------+---------------+---------------------------------------+
| uint32     | 组数          | 后面的分组数                          |
+------------+---------------+---------------------------------------+
| 顺序映射组 | 组[numGroups] | SequentialMapGroup 记录的数组。       |
+------------+---------------+---------------------------------------+

每个顺序映射组记录指定一个字符范围和从第一个字符映射的起始字形
ID。后续字符的字形 ID 按顺序排列。

*SequentialMapGroup 记录：*

+--------+--------------+--------------------------------------------+
| 类型   | 姓名         | 描述                                       |
+========+==============+============================================+
| uint32 | 开始字符编码 | 该组中的第一                               |
|        |              | 个字符编码；请注意，如果该组用于一个或多个 |
|        |              | 16 位字符编码（由 is32 数组确定），则该 32 |
|        |              | 位值将高 16 位设置为零                     |
+--------+--------------+--------------------------------------------+
| uint32 | 结束字符编码 | 该组的最后一个字符编码；与上面列出的       |
|        |              | startCharCode 条件相同                     |
+--------+--------------+--------------------------------------------+
| uint32 | 开始字形ID   | 对应起始字符编码的字形索引                 |
+--------+--------------+--------------------------------------------+

这里有一些注意事项。使用 endCharCode
而不是计数，因为组匹配的比较通常在现有字符编码上完成，并且有 endCharCode
显式保存每个组添加的必要性。必须通过增加 startCharCode
对组进行排序。一个组的 endCharCode 必须小于下一个组的
startCharCode（如果有）。

要确定特定字 (cp) 是否是 32 位代码点的前半部分，可以使用诸如 (is32[ cp /
8 ] & ( 1 << ( 7 - ( cp % 8 ) ) ) 的表达式. 如果它不为零，则该字是 32
位代码点的前半部分。

0 不是 32 位代码点的高位字的特殊值。字体可能不会同时具有代码点 0x0000
的字形和高位字 0x0000 的代码点的字形。

即使字体不包含特定 16 位起始值的字形，指示特定 16 位值是否是 32
位字符编码的开头的压缩位数组的存在也是有用的。这是因为系统软件通常需要知道下一个字符开始前多少字节，即使当前字符映射到丢失的字形也是如此。通过在此表中明确包含此信息，无需将“秘密”知识编码到操作系统中。

尽管创建此格式是为了支持 Unicode
补充平面字符，但它并未得到广泛支持或使用。此外，除了 Unicode
之外，没有其他字符编码使用混合的 16 位/32 位字符。不鼓励使用这种格式。

格式 10：修剪后的数组
------------------------------------------------------

子表格式 10 旨在支持 Unicode 补充平面字符，尽管它并不常用。格式 10
与格式 6
相似，因为它为严格范围的字符编码定义了一个修剪后的数组。但是，它的不同之处在于它使用
32 位字符编码。

*'cmap' 子表格式 10：*

+--------+----------------+------------------------------------------+
| 类型   | 姓名           | 描述                                     |
+========+================+==========================================+
| uint16 | 格式           | 子表格式；设置为 10。                    |
+--------+----------------+------------------------------------------+
| uint16 | 预订的         | 预订的; 设置为 0                         |
+--------+----------------+------------------------------------------+
| uint32 | 长度           | 此子表的字节长度（包括表头）             |
+--------+----------------+------------------------------------------+
| uint32 | 语             | 语言字段的使用要求请参见本文档“          |
|        |                | `'cma                                    |
|        |                | p'子表中语言字段的使用”。 <#language>`__ |
+--------+----------------+------------------------------------------+
| uint32 | 开始字符编码   | 覆盖的第一个字符编码                     |
+--------+----------------+------------------------------------------+
| uint32 | 字符数         | 涵盖的字符编码数量                       |
+--------+----------------+------------------------------------------+
| uint16 | glyphIdArray[] | 涵盖的字符编码的字形索引数组             |
+--------+----------------+------------------------------------------+

此格式未广泛使用且不受 Microsoft 支持。它最适合仅支持连续范围的 Unicode
补充平面字符的字体，但这种字体很少见。

格式 12：分段覆盖
-------------------------------------------------------

这是支持包含补充平面字符（U+10000 到 U+10FFFF）的 Unicode
字符库的字体的标准字符到字形索引映射子表。

包含格式 12 子表的字体也可以包含格式 4
子表，以便与旧应用程序兼容。然而，这不是必需的。有关更多信息，请参阅“\ `建议 <recom#cmap-table>`__\ ”一章。

格式 12 类似于格式4，因为它定义了用于稀疏表示的段。但是，它的不同之处在于它使用 32
位字符编码。

*'cmap' 子表格式 12：*

+------------+---------------+---------------------------------------+
| 类型       | 姓名          | 描述                                  |
+============+===============+=======================================+
| uint16     | 格式          | 子表格式；设置为 12。                 |
+------------+---------------+---------------------------------------+
| uint16     | 预订的        | 预订的; 设置为 0                      |
+------------+---------------+---------------------------------------+
| uint32     | 长度          | 此子表的字节长度（包括表头）          |
+------------+---------------+---------------------------------------+
| uint32     | 语            | 语言字段的使用要求请参见本文档“       |
|            |               | `'cmap'子                             |
|            |               | 表中语言字段的使用”。 <#language>`__  |
+------------+---------------+---------------------------------------+
| uint32     | 组数          | 后面的分组数                          |
+------------+---------------+---------------------------------------+
| 顺序映射组 | 组[numGroups] | SequentialMapGroup 记录的数组。       |
+------------+---------------+---------------------------------------+

顺序映射组记录的格式与用于格式 8 子表的格式相同。然而，关于 16
位字符编码的限定在此不适用，因为字符编码统一为 32 位。

*SequentialMapGroup 记录：*

====== ============ ==========================
类型   姓名         描述
====== ============ ==========================
uint32 开始字符编码 该组中的第一个字符编码
uint32 结束字符编码 该组中的最后一个字符编码
uint32 开始字形ID   对应起始字符编码的字形索引
====== ============ ==========================

必须通过增加 startCharCode 对组进行排序。一个组的 endCharCode
必须小于下一个组的 startCharCode（如果有）。使用 endCharCode
而不是计数，因为组匹配的比较通常在现有字符编码上完成，并且有 endCharCode
显式保存每个组添加的必要性。

格式 13：多对一范围映射
---------------------------------------------------------------------

该子表提供了相同字形用于跨越多个代码空间范围的数百甚至数千个连续字符的情况。尽管这些字体也可以使用其他合适的子表格式，但这种子表格式可能对“最后的手段”字体很有用。（对于“last-resort”字体，另见\ `“head”表 <head>`__\ 标志，第
14 位。）

   *注意：*\ 子表格式 13 与格式 12 结构相同；它仅在 startGlyphID/glyphID
   字段的解释上有所不同。

*'cmap' 子表格式 13：*

+------------+---------------+---------------------------------------+
| 类型       | 姓名          | 描述                                  |
+============+===============+=======================================+
| uint16     | 格式          | 子表格式；设置为 13。                 |
+------------+---------------+---------------------------------------+
| uint16     | 预订的        | 预订的; 设置为 0                      |
+------------+---------------+---------------------------------------+
| uint32     | 长度          | 此子表的字节长度（包括表头）          |
+------------+---------------+---------------------------------------+
| uint32     | 语            | 语言字段的使用要求请参见本文档“       |
|            |               | `'cmap'子                             |
|            |               | 表中语言字段的使用”。 <#language>`__  |
+------------+---------------+---------------------------------------+
| uint32     | 组数          | 后面的分组数                          |
+------------+---------------+---------------------------------------+
| 常量映射组 | 组[numGroups] | ConstantMapGroup 记录数组。           |
+------------+---------------+---------------------------------------+

常量映射组记录具有与顺序映射组记录相同的结构，具有开始和结束字符编码以及映射的字形
ID。但是，相同的字形 ID 适用于指定范围内的所有字符，而不是连续的字形
ID。

*ConstantMapGroup 记录：*

====== ============ ================================
类型   姓名         描述
====== ============ ================================
uint32 开始字符编码 该组中的第一个字符编码
uint32 结束字符编码 该组中的最后一个字符编码
uint32 字形ID       用于组范围内所有字符的字形索引。
====== ============ ================================

格式 14：Unicode 变体序列
------------------------------------------------------------------------

子表格式 14 指定字体支持的 Unicode 变化序列 (UVS)。根据 Unicode
标准，变体序列包括一个基本字符，后跟一个变体选择器。例如，<U+82A6,
U+E0101>。

此子表格式只能在平台 ID 0 和编码 ID 5 下使用。

子表将字体支持的 UVS 分为两类：“默认”和“非默认”UVS。给定一个
UVS，如果通过在 Unicode 'cmap' 子表（即 BMP 子表或 BMP +
补充平面子表）中查找该序列的基本字符获得的字形是用于该序列的字形，那么该序列是默认的
UVS；否则它是一个非默认的 UVS，并且用于该序列的字形在格式 14
子表本身中指定。

页面底部的示例显示了字体供应商如何将格式 14 用于支持 JIS-2004 的字体。

*'cmap' 子表格式 14：*

+------------+---------------------------+---------------------------+
| 类型       | 姓名                      | 描述                      |
+============+===========================+===========================+
| uint16     | 格式                      | 子表格式。设置为 14。     |
+------------+---------------------------+---------------------------+
| uint32     | 长度                      | 此子表                    |
|            |                           | 的字节长度（包括此标头）  |
+------------+---------------------------+---------------------------+
| uint32     | numVarSelectorRecords     | 变化选择器记录的数量      |
+------------+---------------------------+---------------------------+
| 变体选择器 | varSelect                 | VariationSelector         |
|            | or[numVarSelectorRecords] | 记录数组。                |
+------------+---------------------------+---------------------------+

每个变体选择器记录指定一个变体选择器字符，以及用于使用该变体选择器映射变体序列的默认和非默认表的偏移量。

*变化选择器记录：*

+----------+-----------------+---------------------------------------+
| 类型     | 姓名            | 描述                                  |
+==========+=================+=======================================+
| uint24   | 变量选择器      | 变体选择器                            |
+----------+-----------------+---------------------------------------+
| 偏移量32 | 默认UVSOffset   | 从格式 14 子表开始到默认 UVS          |
|          |                 | 表的偏移量。可能为 0。                |
+----------+-----------------+---------------------------------------+
| 偏移量32 | 非默认UVSOffset | 从格式 14 子表开始到非默认 UVS        |
|          |                 | 表的偏移量。可能为 0。                |
+----------+-----------------+---------------------------------------+

变体选择器记录按 varSelector 的升序排序。没有两条记录可能具有相同的
varSelector。

变体选择器记录及其偏移量指向的数据指定变体选择器是记录的 varSelector
值的字体支持的那些 UVS。UVS 的基本字符存储在偏移量指向的表中。UVS
是根据它们是默认的还是非默认的 UVS 来划分的。

用于非默认 UVS 的字形 ID 在 Non-Default UVS 表中指定。

默认 UVS 表
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

默认 UVS 表只是 Unicode
标量值的范围压缩列表，表示使用相关变化选择器记录的 varSelector 的默认
UVS 的基本字符。

*默认UVS表：*

=========== =========================== ========================
类型        姓名                        描述
=========== =========================== ========================
uint32      numUnicodeValueRanges       Unicode 字符范围的数量。
Unicode范围 范围[numUnicodeValueRanges] UnicodeRange 记录数组。
=========== =========================== ========================

每个 Unicode 范围记录指定一个连续的 Unicode 值范围。

*Unicode范围记录：*

====== ============= ==================
类型   姓名          描述
====== ============= ==================
uint24 开始Unicode值 此范围内的第一个值
uint8  附加计数      此范围内的附加值数
====== ============= ==================

例如，范围 U+4E4D – U+4E4F（3 个值）会将 startUnicodeValue 设置为
0x004E4D，将 additionalCount 设置为 2。单例范围会将 additionalCount
设置为 0。

总和 (startUnicodeValue + additionalCount) 不得超过 0xFFFFFF。

Unicode 值范围按 startUnicodeValue
的升序排序。范围不得重叠；即，(startUnicodeValue + additionalCount)
必须小于以下范围的 startUnicodeValue（如果有）。

范围数组中列出的所有代码点都应在 Unicode 'cmap'
子表中具有相应的条目。然而，应用程序可能会遇到并非如此的字体。

非默认 UVS 表
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

非默认 UVS 表是一对 Unicode 标量值和字形 ID 的列表。Unicode
值表示所有使用相关变体选择器记录的 varSelector 的非默认 UVS
的基本字符，并且字形 ID 指定用于 UVS 的字形 ID。

*NonDefaultUVS 表：*

====== =========================== =======================
类型   姓名                        描述
====== =========================== =======================
uint32 numUVSMappings              跟随的 UVS 映射数量
UV映射 uvsMappings[numUVSMappings] UVSMapping 记录的数组。
====== =========================== =======================

每个 UVSMapping 记录为一个基本 Unicode 字符提供一个字形 ID
映射，当该基本字符与当前变体选择器一起用于变体序列时。

*UVSMapping 记录：*

.. container:: has-inner-focus

====== ============ =====================
类型   姓名         描述
====== ============ =====================
uint24 unicodeValue UVS 的基本 Unicode 值
uint16 字形ID       UVS 的字形 ID
====== ============ =====================

UVS 映射按 unicodeValue
的升序排序。此表中没有两个映射可能具有相同的“unicodeValue”值。

通常，在 uvsMappings 数组中列出的代码点将在 Unicode 'cmap'
子表中具有相应的条目。然而，这不是必需的。例如，如果字体旨在用于给定
Unicode 字符仅以变体序列出现的内容，则情况可能并非如此。

例子
~~~~~~~~~~~~~~~~~~~~~

下面是如何在可识别 JIS-2004 变体字形的字体中使用格式 14 'cmap'
子表的示例。此示例中的 CID（字符 ID）指的是 Adob​​e
字符集“Adobe-Japan1”中的 CID（字符
ID），并且可以假定与我们示例中字体中的字形 ID 相同。

JIS-2004 更改了一些代码点的默认字形变体。例如：

| JIS-90：U+82A6 ⇒ CID 1142
| JIS-2004：U+82A6 ⇒ CID 7961

这两种字形变体都通过使用 UVS 得到支持，如 Unicode 的 UVS
注册表中的以下示例所示：

| U+82A6 U+E0100 ⇒ CID 1142
| U+82A6 U+E0101 ⇒ CID 7961

如果字体想要默认支持 JIS-2004 变体，它将：

-  在 Unicode 'cmap' 子表中的 U+82A6 处对字形 ID 7961 进行编码，
-  在 UVS 'cmap' 子表的默认 UVS 表中指定 <U+82A6, U+E0101>（varSelector
   将为 0x0E0101，defaultUVSOffset 将指向包含 0x0082A6 Unicode
   值的数据）
-  在 UVS 'cmap' 子表的非默认 UVS 表中指定 <U+82A6, U+E0100> ⇒ 字形 ID
   1142（varSelector 将为 0x0E0100，nonDefaultBaseUVOffset 将指向包含
   unicodeValue 0x0082A6 和 glyphID 1142 的数据）。

但是，如果字体希望默认支持 JIS-90 变体，它将：

-  在 Unicode 'cmap' 子表中的 U+82A6 处对字形 ID 1142 进行编码，
-  在 UVS 'cmap' 子表的默认 UVS 表中指定 <U+82A6, U+E0100>
-  在 UVS 'cmap' 子表的非默认 UVS 表中指定 <U+82A6, U+E0101> ⇒ 字形 ID
   7961
