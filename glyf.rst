glyf - 字形数据
===============


此表包含描述 TrueType
轮廓格式字体中字形的信息。有关光栅器（缩放器）的信息是指 TrueType
光栅器。有关 TrueType
轮廓的缩放、网格拟合和光栅化的详细信息，请参阅\ `TrueType
基础 <ttch01>`__\ 章节。

表组织
----------------------------------

“glyf”表由一系列字形数据块组成，每个数据块都提供单个字形的描述。字形由标识符（字形
ID）引用，标识符是从零开始的连续整数。字形的总数由“maxp
`”表 <maxp>`__\ 中的 numGlyphs
字段指定。“glyf”表不包括任何整体表头或提供字形数据块偏移量的记录。相反，\ `'loca'
表 <loca>`__\ 提供一个偏移量数组，由字形 ID
索引，它提供了“glyf”表中每个字形数据块的位置。请注意，“glyf”表必须始终与“loca”和“maxp”表一起使用。每个字形数据块的大小是从“位置”表中两个连续偏移之间的差异推断出来的（提供了一个额外的偏移来给出最后一个字形数据块的大小）。作为“local”格式的结果，“glyf”表中的字形数据块必须按字形
ID 顺序排列。

每个字形描述使用以下两种格式之一：

-  简单字形描述直接使用贝塞尔控制点指定字形轮廓。
-  复合字形描述通过引用一个或多个字形 ID 来间接指定字形轮廓以用作组件。

在这两种情况下，字形描述都以字形标题开头，这两种字形描述都通用。

字形标题
-------------------------------

每个字形描述都以标题开头：

*字形标题*

+--------+------------------+----------------------------------------+
| 类型   | 姓名             | 描述                                   |
+========+==================+========================================+
| 整数16 | numberOfContours | 如                                     |
|        |                  | 果轮廓的数量大于或等于零，这是一个简单 |
|        |                  | 的字形。如果为负，这是一个复合字形——值 |
|        |                  | -1 应该用于复合字形。                  |
+--------+------------------+----------------------------------------+
| 整数16 | xMin             | 坐标数据的最小 x。                     |
+--------+------------------+----------------------------------------+
| 整数16 | yMin             | 坐标数据的最小 y。                     |
+--------+------------------+----------------------------------------+
| 整数16 | 最大             | 坐标数据的最大 x。                     |
+--------+------------------+----------------------------------------+
| 整数16 | 最大             | 坐标数据的最大 y。                     |
+--------+------------------+----------------------------------------+

请注意，每个字符的边界矩形定义为左下角为 (xMin, yMin) 和右上角为 (xMax,
yMax)
的矩形。这些值直接从字形的点坐标数据中获得，比较所有曲线上和曲线外的点。光栅化器计算的幻象点是不相关的。请注意，控制点定义的边界框保证包含轮廓，但可能不会紧贴轮廓。

   *注意：*\ 如果已创建字形坐标以使 xMin 等于
   lsb，则缩放器的性能会更好。例如，如果 lsb 为 123，则字形的 xMin 应为
   123。如果 lsb 为 -12，则 xMin 应为 -12。如果 lsb 为 0，则 xMin 为
   0。如果所有字形都是这样完成的，则设置“head”表中标志字段的第 1 位。

..

   *注意：*\ 字形描述不包括侧轴承信息。\ `'hmtx'
   表 <hmtx>`__\ 中提供了左侧方位角，而右侧方位角是从前进宽度（也在'hmtx'
   表中提供）和'glyf'
   表中提供的边界框坐标推断的。对于垂直布局，\ `“vmtx”表 <vmtx>`__\ 中提供了顶部轴承，并推断了底部轴承。光栅化器将以“幻象”点的形式生成侧轴承的表示，这些点作为四个附加点添加到字形描述的末尾，并且可以通过字形指令进行引用和操作。有关幻点的更多背景信息，请参阅\ `指导
   TrueType 字形 <tt_instructing_glyphs#phantoms>`__\ 一章。

在可变字体中，控制点的最小和最大 x 或 y
值可以变化，包含轮廓或实例所有点的紧密边界矩形可能小于或大于默认实例（即，对于字形本表中的说明）。xMin、yMin、xMax
和 yMax
值可能包含也可能不包含实例的派生轮廓。此外，\ `“gvar” <gvar>`__\ 表不提供这些值的增量。如果应用程序需要一个用于字形的非默认实例的边界矩形，则应处理派生的点数据（应用了增量）以确定边界矩形。

简单字形描述
----------------------------------------------

如果 numberOfContours
大于或等于零，这是用于描述字形的信息；也就是说，如果字形不是复合字形。请注意，点编号是从零开始的索引，在字形的所有轮廓上按顺序编号；也就是说，每个轮廓的第一个点号（第一个除外）比前一个轮廓的最后一个点号大一个。

*简单字形表*

+----------------+-------------------------+-------------------------+
| 类型           | 姓名                    | 描述                    |
+================+=========================+=========================+
| uint16         | endPtsOfCon             | 每个轮廓的              |
|                | tours[numberOfContours] | 最后一个点的点索引数组  |
|                |                         | ，按数字递增顺序排列。  |
+----------------+-------------------------+-------------------------+
| uint16         | 指令长度                | 指令的总字节数。如果    |
|                |                         | 指令长度为零，则此字形  |
|                |                         | 不存在任何指令，并且此  |
|                |                         | 字段后直接跟标志字段。  |
+----------------+-------------------------+-------------------------+
| uint8          | 指令[指令长度]          | 字形的指令字节码数组。  |
+----------------+-------------------------+-------------------------+
| uint8          | 标志[*变量*]            | 标志元素数组。          |
|                |                         | 有关标志数组元素数量的  |
|                |                         | 详细信息，请参见下文。  |
+----------------+-------------------------+-------------------------+
| uint8 或 int16 | x坐标[*变量*]           | 轮廓点 x                |
|                |                         | 坐标。有关              |
|                |                         | 坐标数组元素数量的详细  |
|                |                         | 信息，请参见下文。第一  |
|                |                         | 个点的坐标相对于（0,0） |
|                |                         | ；其他是相对于前一点。  |
+----------------+-------------------------+-------------------------+
| uint8 或 int16 | y坐标[*变量*]           | 轮廓点 y                |
|                |                         | 坐标。有关              |
|                |                         | 坐标数组元素数量的详细  |
|                |                         | 信息，请参见下文。第一  |
|                |                         | 个点的坐标相对于（0,0） |
|                |                         | ；其他是相对于前一点。  |
+----------------+-------------------------+-------------------------+

..

   *注意：*\ 在“glyf”表中，一个点的位置不是以绝对值存储的，而是作为相对于前一个点的向量。delta-x
   和 delta-y
   向量表示这些（通常很小的）位置变化。坐标值采用字体设计单位，由“head”表中的\ `unitsPerEm字段定义。 <head>`__\ 请注意，较小的
   unitsPerEm 值将使 delta-x 和 delta-y 值更有可能适合较小的表示形式（8
   位而不是 16 位），尽管需要在级别或精度上进行权衡用于描述轮廓。

flags
数组中的每个元素都是一个字节，每个字节都有多个不同含义的标志位，如下所示。

从逻辑上讲，每个点都有一个标志字节元素、一个 x 坐标和一个 y 坐标。点数由
endPtsOfContours
数组中的最后一项确定。但是请注意，标志字节元素和坐标数组使用打包表示。特别是，如果标志元素的逻辑序列或
x 或 y
坐标序列被重复，则实际标志字节元素或坐标值可以在单个条目中给出，特殊标志用于指示该值重复用于后续的逻辑条目。标志或坐标数组的实际存储大小必须通过解析标志数组条目来确定。有关详细信息，请参阅下面的标志说明。

*简单字形标志*

+------+------------------------------+------------------------------+
| 面具 | 姓名                         | 描述                         |
+======+==============================+==============================+
| 0x01 | ON_CURVE_POINT               | Bit                          |
|      |                              | 0：如果设置，点在曲          |
|      |                              | 线上；否则，它就偏离了曲线。 |
+------+------------------------------+------------------------------+
| 0x02 | X_SHORT_VECTOR               | 位 1：如果设置，则对应的 x   |
|      |                              | 坐标为 1 字节长，符号由      |
|      |                              | X_IS_SAM                     |
|      |                              | E_OR_POSITIVE_X_SHORT_VECTOR |
|      |                              | 标志确定                     |
|      |                              | 。如果未设置，则其解释取决于 |
|      |                              | X_IS_SAM                     |
|      |                              | E_OR_POSITIVE_X_SHORT_VECTOR |
|      |                              | 标志：如果设置了其他标志，则 |
|      |                              | x 坐标与前一个 x             |
|      |                              | 坐标相同，并且没有元素添加到 |
|      |                              | xCoordinates                 |
|      |                              | 数                           |
|      |                              | 组。如果两个标志均未设置，则 |
|      |                              | xCoordinates                 |
|      |                              | 数组中的相                   |
|      |                              | 应元素为两个字节并解释为有符 |
|      |                              | 号整数。有关其他信息，请参阅 |
|      |                              | X_IS_SAM                     |
|      |                              | E_OR_POSITIVE_X_SHORT_VECTOR |
|      |                              | 标志的描述。                 |
+------+------------------------------+------------------------------+
| 0x04 | Y_SHORT_VECTOR               | 第 2 位：如果设置，则对应的  |
|      |                              | y 坐标为 1 字节长，符号由    |
|      |                              | Y_IS_SAM                     |
|      |                              | E_OR_POSITIVE_Y_SHORT_VECTOR |
|      |                              | 标志确定                     |
|      |                              | 。如果未设置，则其解释取决于 |
|      |                              | Y_IS_SAM                     |
|      |                              | E_OR_POSITIVE_Y_SHORT_VECTOR |
|      |                              | 标志：如果设置了其他标志，则 |
|      |                              | y 坐标与前一个 y             |
|      |                              | 坐标相                       |
|      |                              | 同，并且不会将任何元素添加到 |
|      |                              | yCoordinates                 |
|      |                              | 数组                         |
|      |                              | 中。如果两个标志均未设置，则 |
|      |                              | yCoordinates                 |
|      |                              | 数组中的相                   |
|      |                              | 应元素为两个字节并解释为有符 |
|      |                              | 号整数。有关其他信息，请参阅 |
|      |                              | Y_IS_SAM                     |
|      |                              | E_OR_POSITIVE_Y_SHORT_VECTOR |
|      |                              | 标志的描述。                 |
+------+------------------------------+------------------------------+
| 0x08 | REPEAT_FLAG                  | 位                           |
|      |                              | 3                            |
|      |                              | ：如果设置，则下一个字节（读 |
|      |                              | 取为无符号）指定此标志字节在 |
|      |                              | 逻辑标志数组中重复的附加次数 |
|      |                              | -                            |
|      |                              | 即在此条目之                 |
|      |                              | 后插入的附加逻辑标志条目的数 |
|      |                              | 量。（在扩展的逻辑数组中，该 |
|      |                              | 位被忽略。）这样，列出的标志 |
|      |                              | 数可以小于字形描述中的点数。 |
+------+------------------------------+------------------------------+
| 0x10 | X_IS_SAM                     | 位                           |
|      | E_OR_POSITIVE_X_SHORT_VECTOR | 4：此标志有两个含义，取决于  |
|      |                              | X_SHORT_VECTOR               |
|      |                              | 标志的设置方式。如果设置了   |
|      |                              | X_SHORT_V                    |
|      |                              | ECTOR，则该位描述值的符号，1 |
|      |                              | 等于正，0 等于负。如果未设置 |
|      |                              | X_SHORT_VECTOR               |
|      |                              | 并且设置了该位，则当前 x     |
|      |                              | 坐标与之前的 x               |
|      |                              | 坐标相同。如果               |
|      |                              | X_SHORT_VECTOR               |
|      |                              | 未设置且该位也未设置，则当前 |
|      |                              | x 坐标为带符号的 16          |
|      |                              | 位增量向量。                 |
+------+------------------------------+------------------------------+
| 0x20 | Y_IS_SAM                     | 位                           |
|      | E_OR_POSITIVE_Y_SHORT_VECTOR | 5：该标志有两个含义，取决于  |
|      |                              | Y_SHORT_VECTOR               |
|      |                              | 标志的设置方式。如果设置了   |
|      |                              | Y_SHORT_V                    |
|      |                              | ECTOR，则该位描述值的符号，1 |
|      |                              | 等于正，0 等于负。如果未设置 |
|      |                              | Y_SHORT_VECTOR               |
|      |                              | 并且设置了该位，则当前 y     |
|      |                              | 坐标与之前的 y               |
|      |                              | 坐标相同。如果               |
|      |                              | Y_SHORT_VECTOR               |
|      |                              | 未设置且该位也未设置，则当前 |
|      |                              | y 坐标为带符号的 16          |
|      |                              | 位增量向量。                 |
+------+------------------------------+------------------------------+
| 0x40 | OVERLAP_SIMPLE               | 位                           |
|      |                              | 6：如果设置，字              |
|      |                              | 形描述中的轮廓可能会重叠。在 |
|      |                              | OpenType                     |
|      |                              | 中不需要使用                 |
|      |                              | 这个标志——也就是说，在没有设 |
|      |                              | 置这个标志的情况下让轮廓重叠 |
|      |                              | 是有效的。但是，它可能会影响 |
|      |                              | 某些平台中的行为。\ `（有关  |
|      |                              | Apple                        |
|      |                              | 平台                         |
|      |                              | 行为的详细信息，请参阅Apple  |
|      |                              | 规范 <https://develo         |
|      |                              | per.apple.com/fonts/TrueType |
|      |                              | -Reference-Manual/RM06/Chap6 |
|      |                              | AATIntro.html>`__\ 中“重叠轮 |
|      |                              | 廓”的讨论。）使用时，它必须  |
|      |                              | 设置在字形的第一个标志字节上 |
|      |                              | 。请参阅下面的其他详细信息。 |
+------+------------------------------+------------------------------+
| 0x80 | 预订的                       | 位 7 保留：设置为零。        |
+------+------------------------------+------------------------------+

当轮廓重叠时，需要一种非零填充算法来避免丢失。一些光栅器实现使用
OVERLAP_SIMPLE
标志来确保使用非零填充算法而不是奇偶填充算法。始终使用非零填充算法的实现将忽略此标志。请注意，某些实现可能会专门在非可变字体中检查此标志，但始终对可变字体使用非零填充算法。当字形具有重叠轮廓时，可以使用此标志来提供字体的广泛互操作性——尤其是非可变字体。

请注意，可变字体通常使用重叠的轮廓。这对于为可变字体的特定实例生成静态字体数据的工具有影响，如果需要派生字体的广泛互操作性：如果字形在给定实例中具有重叠轮廓，则该工具应将此标志设置为派生的字形数据，或者应该合并轮廓以消除单独轮廓的重叠。

   *注意：*\ 下面描述的 OVERLAP_COMPOUND
   标志与复合字形具有类似的目的。为 OVERLAP_SIMPLE
   标志描述的相同注意事项也适用于 OVERLAP_COMPOUND 标志。

复合字形描述
-------------------------------------------------

如果 numberOfContours 为负数，则使用复合字形描述。

   *注意：*\ 建议使用 numberOfContours 值 -1 来指示复合字形。

复合字形或复合字形通过引用作为组件合并到复合字形中的其他字形来间接描述轮廓。当多个字形需要相同的轮廓时，这很有用，因为它为跨多个字形重复的轮廓提供了一致性，并且还可以显着减小尺寸。

为了更清楚地解释复合字形，将使用术语\ *父*\ 和\ *子*\ ，复合字形描述是父字形，而作为组件引用的其他字形是子字形。

复合字形可以嵌套在其他复合字形中——也就是说，复合字形父级可以包含其他复合字形作为子组件。因此，复合字形描述是有向图。该图必须是非循环的，通过该图的每条路径都通向一个简单的字形作为叶节点。\ `'maxp
' <maxp>`__\ 表中的 maxComponentDepth
字段设置为指示字体中所有复合字形的最大嵌套深度。没有必须支持的最小嵌套深度。为了使字体与最广泛的实现兼容，应避免组合嵌套。

   *注意：*\ 某些 PostScript
   设备（可能还有其他实现）无法正确渲染具有嵌套复合描述的字形。具有嵌套复合的复合字形描述可以展平以仅引用简单字形作为子组件。这可能会失去重复信息删除的一些好处，但仍然可以保留显着的尺寸节省优势以及提供更广泛的兼容性。

复合字形描述的数据由每个子组件字形的数据块序列组成。每个组件的数据中的标志用于指示序列中是否有其他组件。该序列按给定的顺序处理，每个子字形的轮廓并入父字形。当一个子节点的轮廓被合并时，它的控制点被重新编号，以在之前合并到父节点的所有点之后依次跟随。

每个字形都有一个基于其控制点的 x 和 y
坐标定位在字体设计网格内的轮廓。当作为子代并入复合字形时，父代可以控制子代轮廓在父代设计网格中的位置。这可以通过两种不同的方式完成：通过指定添加到子控制点的
(x, y)
坐标的矢量偏移量，或者通过从子控制点的轮廓中指定一个控制点，该控制点与父控制点中的指定控制点对齐。第二种机制假设一些轮廓已经合并到父级中，因此不能用于第一个组件字形。

当子字形合并到父字形时，父字形还可以指定要应用于子字形的比例或其他仿射变换。变换可以影响用于定位子字形的偏移向量；有关更多详细信息，请参见下文。

每个组件字形都可以包含适用于其轮廓的说明。父复合字形描述可以包括在针对每个子字形的指令都已执行之后应用于整个复合字形的指令。

在将每个孩子纳入父母之前，对其进行处理，定义幻象点并执行提示指令。因此，如果孩子的放置是通过点对齐来完成的，那么孩子的幻象点可以用于这种对齐，并且已经执行了影响他们的点的孩子字形中的指令。

每个子组件的数据块以两个 uint16 值开头：一个标志字段和一个字形
ID。这些后跟两个参数字段，尽管参数的大小和解释根据设置的标志而有所不同。描述转换的可选字段可能会跟随参数，具体取决于标志。

*组件字形表*

+----------------------------+----------+----------------------------+
| 类型                       | 姓名     | 描述                       |
+============================+==========+============================+
| uint16                     | 旗帜     | 组件标志                   |
+----------------------------+----------+----------------------------+
| uint16                     | 字形索引 | 组件的字形索引             |
+----------------------------+----------+----------------------------+
| uint8、int8、uint16 或     | 论据1    | 组件或点编号的 x           |
| int16                      |          | 偏移量                     |
|                            |          | ；类型取决于组件标志中的位 |
|                            |          | 0 和 1                     |
+----------------------------+----------+----------------------------+
| uint8、int8、uint16 或     | 论据2    | 组件或点编号的 y           |
| int16                      |          | 偏移                       |
|                            |          | ；类型取决于组件标志中的位 |
|                            |          | 0 和 1                     |
+----------------------------+----------+----------------------------+
| 转换选项                   |          |                            |
+----------------------------+----------+----------------------------+

下面的 C
伪代码片段显示了组件字形信息序列是如何存储和解析的；标志位的定义遵循此片段：

.. code:: 

   do {
       uint16 flags;
       uint16 glyphIndex;
       if ( flags & ARG_1_AND_2_ARE_WORDS) {
       (int16 or FWORD) argument1;
       (int16 or FWORD) argument2;
       } else {
           uint16 arg1and2; /* (arg1 << 8) | arg2 */
       }
       if ( flags & WE_HAVE_A_SCALE ) {
           F2DOT14  scale;    /* Format 2.14 */
       } else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) {
           F2DOT14  xscale;    /* Format 2.14 */
           F2DOT14  yscale;    /* Format 2.14 */
       } else if ( flags & WE_HAVE_A_TWO_BY_TWO ) {
           F2DOT14  xscale;    /* Format 2.14 */
           F2DOT14  scale01;   /* Format 2.14 */
           F2DOT14  scale10;   /* Format 2.14 */
           F2DOT14  yscale;    /* Format 2.14 */
       }
   } while ( flags & MORE_COMPONENTS )
   if (flags & WE_HAVE_INSTR){
       uint16 numInstr
       uint8 instr[numInstr]

定义了以下组件字形标志：

*组件字形标志*

+--------+---------------------------+-----------------------------+
| 面具   | 姓名                      | 描述                        |
+========+===========================+=============================+
| 0x0001 | ARG_1_AND_2_ARE_WORDS     | 位 0：如果设置，参数为 16   |
|        |                           | 位（uint16 或               |
|        |                           | int16                       |
|        |                           | ）；否则，它们是字节（uint8 |
|        |                           | 或 int8）。                 |
+--------+---------------------------+-----------------------------+
| 0x0002 | ARGS_ARE_XY_VALUES        | 位                          |
|        |                           | 1：如                       |
|        |                           | 果已设置，则参数是带符号的  |
|        |                           | xy                          |
|        |                           | 值                          |
|        |                           | ；否则，它们是无符号点数。  |
+--------+---------------------------+-----------------------------+
| 0x0004 | ROUND_XY_TO_GRID          | 位 2：如果已设置且          |
|        |                           | ARGS_ARE_XY_VALUES          |
|        |                           | 也已设置，则 xy             |
|        |                           | 值将四舍五入                |
|        |                           | 到最近的网格线。如果未设置  |
|        |                           | A                           |
|        |                           | RGS_ARE_XY_VALUES，则忽略。 |
+--------+---------------------------+-----------------------------+
| 0x0008 | WE_HAVE_A_SCALE           | 位                          |
|        |                           | 3：这表示该组件有           |
|        |                           | 一个简单的刻度。否则，比例  |
|        |                           | = 1.0。                     |
+--------+---------------------------+-----------------------------+
| 0x0020 | 更多组件                  | 第 5                        |
|        |                           | 位：表示在该                |
|        |                           | 字形之后至少还有一个字形。  |
+--------+---------------------------+-----------------------------+
| 0x0040 | WE_HAVE_AN_X_AND_Y_SCALE  | 位 6：x 方向将使用与 y      |
|        |                           | 方向不同的比例。            |
+--------+---------------------------+-----------------------------+
| 0x0080 | WE_HAVE_A_TWO_BY_TWO      | 位 7：有一个 2 x 2          |
|        |                           | 转换将用于缩放组件。        |
+--------+---------------------------+-----------------------------+
| 0x0100 | WE_HAVE_INSTRUCTIONS      | 位                          |
|        |                           | 8：在最后一个               |
|        |                           | 组件之后是复合字符的指令。  |
+--------+---------------------------+-----------------------------+
| 0x0200 | USE_MY_METRICS            | 位                          |
|        |                           | 9：如果设置，这将强制复合的 |
|        |                           | aw 和 lsb（和               |
|        |                           | rsb）等于                   |
|        |                           | 来自该组件字形的那些。这适  |
|        |                           | 用于有提示和无提示的字形。  |
+--------+---------------------------+-----------------------------+
| 0x0400 | OVERLAP_COMPOUND          | 位                          |
|        |                           | 10：如果设                  |
|        |                           | 置，复合字形的组件重叠。在  |
|        |                           | OpenType                    |
|        |                           | 中不需要使用这个            |
|        |                           | 标志——也就是说，在没有设置  |
|        |                           | 这个标志的情况下让组件重叠  |
|        |                           | 是有效的。但是，它可能会影  |
|        |                           | 响某些平台中的行为。（有关  |
|        |                           | Apple                       |
|        |                           | 平台行为                    |
|        |                           | 的详细信息，请参阅\ `Apple  |
|        |                           | 规范                        |
|        |                           | <https://developer.apple.co |
|        |                           | m/fonts/TrueType-Reference- |
|        |                           | Manual/RM06/Chap6glyf.html> |
|        |                           | `__\ 。）使用时，必须在第一 |
|        |                           | 个组件的标志字上设置它。有  |
|        |                           | 关简单字形描述中使用的类似  |
|        |                           | OVERLAP_SIMPLE              |
|        |                           | 标                          |
|        |                           | 志，请参见上面的附加说明。  |
+--------+---------------------------+-----------------------------+
| 0x0800 | SCALED_COMPONENT_OFFSET   | 第 11                       |
|        |                           | 位：复合设计用              |
|        |                           | 于缩放分量偏移。如果未设置  |
|        |                           | A                           |
|        |                           | RGS_ARE_XY_VALUES，则忽略。 |
+--------+---------------------------+-----------------------------+
| 0x1000 | UNSCALED_COMPONENT_OFFSET | 位                          |
|        |                           | 12：复合设计为不            |
|        |                           | 缩放组件偏移量。如果未设置  |
|        |                           | A                           |
|        |                           | RGS_ARE_XY_VALUES，则忽略。 |
+--------+---------------------------+-----------------------------+
| 0xE010 | 预订的                    | 第 4、13、14 和 15          |
|        |                           | 位保留：设置为 0。          |
+--------+---------------------------+-----------------------------+

Argument1 和 Argument2
用于确定子组件字形在父复合字形中的位置。根据是否设置了
ARGS_ARE_XY_VALUES
标志，它们被解释为偏移向量或来自父节点和子节点的点。必须始终为复合字形的第一个组件设置此标志。

如果设置了 ARGS_ARE_XY_VALUES，则 Argument1 和 Argument 2
被解释为设计坐标系中的单位，并将偏移矢量 (x, y) = (Argument1, Argument2)
添加到组件字形的每个控制点的坐标中。在可变字体中，偏移向量可以通过
'gvar' 表中的 deltas
进行修改；有关详细信息，请参阅“gvar”一章中\ `复合字形的点编号和处理。 <gvar#point-numbers-and-processing-for-composite-glyphs>`__\ 如果提供了比例或变换矩阵，则偏移向量可能会或可能不会受到变换；有关详细信息，请参阅下面对
SCALED_COMPONENT_OFFSET 和 UNSCALED_COMPONENT_OFFSET 标志的讨论。

如果设置了 ARGS_ARE_XY_VALUES 并且还设置了 ROUND_XY_TO_GRID
标志，则偏移矢量（在应用任何变换和变化增量之后）是网格拟合的，x 和 y
值四舍五入到最近的像素网格线。

如果 ARGS_ARE_XY_VALUES 未设置，则 Argument1
是父字形中的点编号（来自合并的轮廓并从先前的组件字形重新编号）；Argument2
是来自子组件字形的点号（在重新编号之前）。可以参考来自父母或孩子的幻象点。通过对齐两个点，子组件字形位于父字形内。如果提供了比例或变换矩阵，则在对齐点之前将变换应用于子点。

在可变字体中，当组件通过点对齐定位时，增量会在对齐完成之前应用于组件字形。为要应用于由点对齐定位的组件的父复合字形指定的任何增量都将被忽略。有关详细信息，请参阅“gvar”一章中\ `复合字形的点编号和处理。 <gvar#point-numbers-and-processing-for-composite-glyphs>`__

WE_HAVE_A_SCALE、WE_HAVE_AN_X_AND_Y_SCALE 和 WE_HAVE_A_TWO_BY_TWO
标志是互斥的：最多只能设置一个。如果设置了
WE_HAVE_A_SCALE，则会将一个额外的 F2DOT14
值附加到组件字形数据；如果设置了 WE_HAVE_AN_X_AND_Y_SCALE，则附加两个
F2DOT14 值；如果 WE_HAVE_A_TWO_BY_TWO，则附加四个 F2DOT14
值。子组件字形在被合并到父复合字形中时被转换，在父组件的网格拟合之前。变换可以影响用于定位子元素的偏移向量；有关详细信息，请参阅下面对
SCALED_COMPONENT_OFFSET 和 UNSCALED_COMPONENT_OFFSET 标志的讨论。

USE_MY_METRICS 的目的是强制 lsb 和 rsb
采用从组件字形获得的值。例如，i-circumflex (U+00EF) 通常由抑扬符和无点-i
组成。为了强制组合具有与 dotless-i 相同的度量，请为组合的 dotless-i
组件设置 USE_MY_METRICS。如果没有该位，则 rsb 和 lsb
将根据复合的“hmtx”条目计算（或者需要使用 TrueType 指令显式设置）。

请注意，对于旋转的复合组件，USE_MY_METRICS 操作的行为是未定义的。

SCALED_COMPONENT_OFFSET 和 UNSCALED_COMPONENT_OFFSET
标志用于确定在缩放组件字形时如何解释 x 和 y 偏移值。如果设置了
SCALED_COMPONENT_OFFSET 标志，则 x 和 y
偏移值被视为在组件字形的坐标系中，并且缩放变换应用于这两个值。如果设置了
UNSCALED_COMPONENT_OFFSET 标志，则 x 和 y
偏移值被视为在当前字形的坐标系中，并且比例变换不会应用于任一值。如果两个标志都没有设置，则光栅化器将应用默认行为。在
Microsoft 和 Apple 平台上，默认行为与设置 UNSCALED_COMPONENT_OFFSET
标志时的行为相同；建议所有光栅化器实现都使用此行为。如果字体同时设置了两个标志，这是无效的；在这种情况下，光栅化器应该使用其默认行为。
